General docstring format:
"""
    Summary line.

    Extended description of function.

    Parameters
    ----------
    arg1 : int
        Description of arg1
    arg2 : str
        Description of arg2

    Returns
    -------
    int
        Description of return value

    """

*** NOTES ***
Background = rgb(127, 127, 127)



@Singleton
class App
    def __init__()
        create root
        create all frames, canvases, labels, etc. and grid them all.

    def make_bindings(game)
        Bind keypresses and buttons

    def reset_game_cvs(new_image)
        Reset the game_canvas to show new_image

    def reset_next_cvs(new_image)
        Reset the next_canvas to show new_image

    def get_ready()
        Create a popup explaining controls and giving a button to click to start the game.

    def lose(game)
        Game Over popup window. Display stats. Two buttons: one to play again one to quit.


class Game
    A object that keeps track of a grid 10x20 where the game will be ran.
    Contains functions for rendering, piece movement, and coordinate checking

    def __init__()
        self.app = App.instance()

    def prepare()
        Create all function variables and set them to init vals or None
        Create a list to keep track of all static blocks.
        Create a var for current piece being used. Set to None
        self.speed
        self.hold = None
        lower_loop = Lower_Piece_Thread()
        Create Piece_Buffer
        App.get_ready() then self.start()

    def start()
        current piece = self.Piece_Buffer().next()
        lower_loop.start()

    def hold()
        self.hold = self.current.copy()
        self.current = Piece_Buffer.next()
        Update hold_cvs


    @property   # Getter
    def static_block_list()
        return the list
    @static_block_list.setter
    def static_block_list(_PIECE_object)
        Iterate through the _PIECE_object and add each block to the list
        For each block being added to the list, list[Block.coord] = Block.color
        If not a _PIECE_object, make all elements None.


    def lower_piece()
        temp variable describing new position. Test to see if this temp var conflicts with permanent gameboard pieces (including checking for IndexError for if piece is at the bottom). If it does, this piece becomes permanent and carry on to next piece. If not make temp var the new coords and update_game_field().

    def rotate_piece()
        calls the objects rotate method and checks to see if it conflicts with gameboard. If so, pass (ignore rotation). Otherwise, make it so and update_game_field().

    def move_left/right()
        get the coords of the current piece, subtract/add 1 to each x coord and test for conflicts with current gameboard (including if it falls off the game field). If so, ignore the movement. Otherwise change the piece's coords to match and update_game_field().

    def fast_drop()
        drop to the lowest unconflicting spot and become permanent. Iterate through lower_piece until it becomes permanent

    def make_permanent()
        makes the once dynamic _PIECE_object a static collection of Block objects. Do this by iterating through the piece object and adding the Block objects to the gameboard's list of static blocks. If there is a block that raises an IndexError (higher than the top of the game field), lose game.
        Then check rows affected by these new blocks. If any row is completed, remove them from the gameboard's list and add to score and speed.
        At sometime in this procession, call Piece_Buffer to find next current piece.
        Do update_game_field() or a special effect for lines completed
        Stop mainloop() and lower_piece_loop in some of these cases


    async def update_game_field()
        new_image = self.render()
        App.instance().reset_game_cvs(new_image)

    def render()
        Adds _PIECE_object's coords to the static_block_list (not actually, via by copy or just adding it post what happens next). The current _PIECE_object's image will often fall off the edges of this image, account for this and cut those parts off. Create a big image for a blank game field. For each coord, create a square image of the color given at that coord. For each square image, replace that part of the image (at that coord, transformed to be in pixels). Finally, return that image.


    class Lower_Piece_Thread
        def __init__()
            current = None

        def start()
            Run thread() and set current object to that thread (not right term. future, subthread, something) object. Research exactly how to get this thread object in asyncio

        def stop()
            if current is None: pass
            end the thread referenced by current. Research how to do this. thread.exit() or something like that.
            current = None

        async def thread()
            constant loop in separate thread to continuously call Game.lower_piece.
            Use game.speed in a wait() funciton


    class Piece_Buffer
        Iterator that continuously creates random _PIECE_objects. 5 are kept in a list at all times. Will be iterated by the GameBoard object itself.

        def __init__()
        Piece list = []
            Call rand_piece() 5 times to fill initial piece list

        def rand_piece()
            Randomly create a _PIECE_object and add to the piece list

        async def update_next_cvs()
            Call _PIECE_.render() for each piece in the piece list and stitch them together.
            App.instance().reset_next_cvs(new_image)

        def __iter__()
        def __next__()
            pop first piece out of list. rand_piece() a replacement.
            update_next_cvs()
            return poped _PIECE_object


        for each tetris piece, inherit from a general PIECE object
        class _PIECE_
            class level var that define the shape (coords of each block)
            class level var that give the color of the shape's Blocks
            iterator - when iterated create self.Block objects and return all of them

            def __init__()
                Create a coords variable to record current position on gameboard

            def __iter__()
                foreach coord create a Block object and store it in a list var

            def __next__()
                return a Block object from the blocks list var

            def rotate(current_coords, bool left/right)
                takes the current coordinates and applies the correct transformation to return new coordinates for where the piece will be after the spin.

            def render()
                create a image representing the piece.
                Pad the image according to a global piece padding variable.
                Return the image

            class Block
                A 1 by 1 block that is part of a _PIECE_.
                Has a coord variable

                def __init__(coord, _PIECE_'s_color)
                    self.coord = coord
                    self.color = color

if __name__ == '__main__':
    Game().prepare()
